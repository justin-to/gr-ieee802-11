#include <stdlib.h>
#include <stdio.h>

#include "hash_drgb.h"
#include "sha256.h"

Status hash_df(BYTE* inputStr, 
               uint32_t inputStrLen,
               uint32_t bytesToReturn,
               BYTE* outputString,
               BYTE* frontAppendByte)
{
    SHA256_CTX sha;

    BYTE* temp;             // Pointer to store all data generated by hash
    uint8_t numHashes;      // Number of hashes necessary for correct
                            //  bit size (called len in NIST800-90A)
    uint8_t counter[] = {0x01};
    uint8_t numBitsArr[4];
    int i;

    // Check inputs
    if ((inputStr == NULL && inputStrLen != 0) ||
        (bytesToReturn == 0 || bytesToReturn > SEED_LENGTH) ||
        (outputString == NULL))
    {
        return ERROR;    
    }

    // Populate numBitsArr
    *((uint32_t*)numBitsArr) = bytesToReturn * 8;

    // Calculate numHashes
    numHashes = bytesToReturn / SHA256_BLOCK_SIZE;
    numHashes = (bytesToReturn % SHA256_BLOCK_SIZE) ? 
                    numHashes + 1 : numHashes;

    // Allocate space for temp
    temp = malloc(SHA256_BLOCK_SIZE * numHashes);
    
    for (i = 0; i < numHashes; i++)
    {
        sha256_init(&sha);
        sha256_update(&sha, counter, 1);
        sha256_update(&sha, numBitsArr, 4);
        if (frontAppendByte != NULL)
        {
            sha256_update(&sha, frontAppendByte, 1);
        }
        sha256_update(&sha, inputStr, inputStrLen);
        sha256_final(&sha, (temp + i * SHA256_BLOCK_SIZE)); 

        counter[0]++;
    }

    // Set the values to the 
    for (i = 0; i < bytesToReturn; i++)
    {
        outputString[i] = temp[i];
    }

    free(temp);

    return SUCCESS;
}

void hash_drgb_init(Hash_DRGB* drgb, 
                    BYTE* seedInput, 
                    uint32_t seedInputLen,
                    BYTE* nonce, 
                    uint32_t nonceInputLen,
                    BYTE* personalizationString,
                    uint32_t perStrLen)
{
    BYTE* seedMaterial;
    BYTE appendVal[] = {0x00};
    int i;
    int seedMaterialLen;

    // Set the seed material 
    seedMaterialLen = seedInputLen + nonceInputLen + perStrLen;
    seedMaterial = (BYTE*)  malloc(seedMaterialLen);
    for (i = 0; i < seedMaterialLen; i++)
    {
        if (i < seedInputLen)
        {
            seedMaterial[i] = seedInput[i];
        }
        else if (i < seedInputLen + nonceInputLen)
        {
            seedMaterial[i] = nonce[i - seedInputLen];
        }
        else
        {
            seedMaterial[i] = personalizationString
                                [i - seedInputLen - nonceInputLen];
        }
        
    }

    // Get the seed and set it to currentValue
    drgb->currentValue = (BYTE*) malloc(SEED_LENGTH);
    if(hash_df(seedMaterial, 
               seedMaterialLen, 
               SEED_LENGTH, 
               drgb->currentValue,
               NULL)) 
    {
        fprintf(stderr, "[ERROR] hash_df failed to generate seed");
    }
    free(seedMaterial);

    // Get the constant value and set it
    drgb->constValue = (BYTE*) malloc(SEED_LENGTH);
    if(hash_df(drgb->currentValue,  // Pass the seed in 
               SEED_LENGTH,         
               SEED_LENGTH, 
               drgb->constValue,
               appendVal))
    {
        fprintf(stderr, "[ERROR] hash_df failed to generate C");
    }

    drgb->reseedCounter = 1;
}

void hash_drgb_reseed(Hash_DRGB* drgb,
                      BYTE* seedInput,
                      uint32_t seedInputLen,
                      BYTE* additionalStr,
                      uint32_t additionalStrLen)
{
    BYTE* seedMaterial;
    BYTE appendVal[] = {0x01};
    int i;
    int seedMaterialLen;

    // Set the seed material 
    seedMaterialLen = seedInputLen + additionalStrLen + SEED_LENGTH;
    seedMaterial = (BYTE*) malloc(seedMaterialLen);
    for (i = 0; i < seedMaterialLen; i++)
    {
        if (i < SEED_LENGTH)
        {
            seedMaterial[i] = drgb->currentValue[i];
        }
        else if (i < SEED_LENGTH + seedInputLen)
        {
            seedMaterial[i] = seedInput[i - SEED_LENGTH];
        }
        else
        {
            seedMaterial[i] = additionalStr[i - seedInputLen - SEED_LENGTH];
        }   
    }

    // Get the seed and set it to currentValue
    if(hash_df(seedMaterial, 
               seedMaterialLen, 
               SEED_LENGTH, 
               drgb->currentValue,
               appendVal)) 
    {
        fprintf(stderr, "[ERROR] hash_df failed to generate seed");
    }
    free(seedMaterial);

    // Get the constant value and set it
    appendVal[0] = 0x00;
    if(hash_df(drgb->currentValue,  // Pass the seed in 
               SEED_LENGTH,         
               SEED_LENGTH, 
               drgb->constValue,
               appendVal))
    {
        fprintf(stderr, "[ERROR] hash_df failed to generate C");
    }

    drgb->reseedCounter = 1;
}

Status hash_drgb_get_rand(Hash_DRGB* drgb, 
                          BYTE* buffer,
                          uint32_t bytes, 
                          BYTE* additionalStr,
                          uint32_t additionalStrLen)
{
    SHA256_CTX sha;
    BYTE temp[SHA256_BLOCK_SIZE];
    BYTE appendVal[] = {0x02};

    // Check if the drgb needs to be reseeded
    if (drgb->reseedCounter > RESEED_INTERVAL) 
    {
        return ERROR;
    }

    // Handle additional information
    if (additionalStrLen != 0)
    {
        // Generate value modifier (w in NIST)
        sha256_init(&sha);
        sha256_update(&sha, appendVal, 1);
        sha256_update(&sha, drgb->currentValue, SEED_LENGTH);
        sha256_update(&sha, additionalStr, additionalStrLen);
        sha256_final(&sha, temp);

        _add_byte_arrs(drgb->currentValue, 
                       temp, 
                       drgb->currentValue, 
                       SHA256_BLOCK_SIZE);
    }

    // Get the random bytes
    _hash_gen(buffer, bytes, drgb->currentValue);

    // Generate the Hash modifier (H in NIST800-90A)
    appendVal[0] = 0x03;
    sha256_init(&sha);
    sha256_update(&sha, appendVal, 1);
    sha256_update(&sha, drgb->currentValue, SEED_LENGTH);
    sha256_final(&sha, temp);

    // Update value
    _add_byte_arrs(drgb->currentValue, 
                   temp, 
                   drgb->currentValue,  
                   SEED_LENGTH);
    _add_byte_arrs(drgb->currentValue, 
                   drgb->constValue, 
                   drgb->currentValue, 
                   SEED_LENGTH);
    _add_byte_arr_int(drgb->currentValue, 
                      drgb->reseedCounter, 
                      drgb->currentValue, 
                      SEED_LENGTH);

    // Update reseed value
    drgb->reseedCounter++; 

    return SUCCESS; 
}

void _hash_gen(BYTE* buffer,
               uint32_t bytes,
               BYTE* value)
{
    SHA256_CTX sha;
    BYTE hashData[SEED_LENGTH];
    BYTE* temp;
    uint32_t numHashes;
    int i;        

    // Determine the number of hashes necessary
    numHashes = bytes / SHA256_BLOCK_SIZE;
    numHashes = (bytes % SHA256_BLOCK_SIZE) ? 
                    numHashes + 1 : numHashes;

    // Allocate space for hash output
    temp = (BYTE*) malloc(numHashes * SHA256_BLOCK_SIZE);

    // Initialize hashData
    for (i = 0; i < SEED_LENGTH; i++)
    {
        hashData[i] = value[i];
    }

    // Get hash output
    for (i = 0; i < numHashes; i++)
    {
        sha256_init(&sha);
        sha256_update(&sha, hashData, SEED_LENGTH);
        sha256_final(&sha, (temp + i * SHA256_BLOCK_SIZE)); 

        _add_byte_arr_int(hashData,
                          1,
                          hashData,
                          SEED_LENGTH);
    }

    // Set the output data
    for (i = 0; i < bytes; i++)
    {
        buffer[i] = temp[i];
    }
}

void _add_byte_arrs(BYTE* op1, 
                    BYTE* op2, 
                    BYTE* res,
                    uint32_t size)
{
    long i;
    uint8_t carry;
    uint16_t temp;

    carry = 0;

    for (i = 0; i < size; i++)
    {
        temp = (uint16_t)op1[i] + (uint16_t)op2[i];

        if (carry)
        {
            temp++;
        }

        if (temp >= 0xFF)
        {
            carry = 1;
        }
        else
        {
            carry = 0;
        }
        
        temp = temp % 0xFF;

        res[i] = temp; 
    }
}

void _add_byte_arr_int(BYTE* op1,
                       uint64_t op2,
                       BYTE* res,
                       uint32_t size)
{
    long i;
    uint8_t carry;
    uint16_t temp;
    uint8_t* op2Arr;

    op2Arr = (uint8_t*)&op2;

    carry = 0;

    for (i = 0; i < 8; i++)
    {
        temp = (uint16_t)op1[i] + 
               (uint16_t)op2Arr[i];

        if (carry)
        {
            temp++;
        }

        if (temp >= 0xFF)
        {
            carry = 1;
        }
        else
        {
            carry = 0;
        }
        
        temp = temp % 0xFF;

        res[i] = temp; 
    }

    while (i < size && carry)
    {
        op1[i]++;

        if (op1[i] == 0x00)
        {
            carry = 1;
        }
        else
        {
            carry = 0;
        }
        
        i++;
    }
}

void hash_drgb_clean(Hash_DRGB* drgb)
{
    free(drgb->constValue);
    free(drgb->currentValue);
} 